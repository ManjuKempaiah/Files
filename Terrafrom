terraform init
terraform plan
terraform apply
terrform provider
terraform apply -auto-approve
terraform destroy -auto-approve
terraform state list

terraform fmt --- Formats the Code -- To Check the alignment of the code
terraform validate -- Validates the Code -- To Check the Syntax of the code

terraform apply -auto-approve -var region=eu-north-1
terraform apply -auto-approve -var-file=dev.tfvars

.terraform
.terraform.lock.hcl

terraform.tfstate

terraform apply -auto-approve --target=resource_type.logical_name
terraform apply -auto-approve --target=aws_subnet.main

terraform destroy -auto-approve --target=resource_type.logical_name
terraform destroy -auto-approve --target=aws_subnet.main

terraform taint resource_type.logical_name
terraform apply -auto-approve

terraform import resource_type.logical_name resource_id


terraform workspace new workspace_name
terraform workspace select workspace_name
terraform workspace delete workspace_name
terraform workspace show
terraform workspace list

terraform state pull

The terraform state pull command is used to download the current state file from the remote backend (such as an S3 bucket) and display it in your terminal

terraform state pull > backup.tfstate

This command saves the state file as backup.tfstate in your local directory.

-------------------------------------------------------------------------------

The terraform state push command is used to manually upload a Terraform state file to a remote backend, replacing the current state file stored there

terraform state push <path_to_state_file>

terraform state push backup.tfstate

----------------------------------------------------------------------------------
	
provider "aws" {
  region = "eu-north-1"
}

terraform {
  backend "s3" {
    bucket         = "roopa-terraform-bucket"
    region         = "eu-north-1"
    key            = "terraform.tfstate"
    dynamodb_table = "tf-statelock"
  }
}

-------------------------------------------------------------------

resource "aws_vpc" "main" {
  cidr_block       = "10.0.0.0/16"
  instance_tenancy = "default"

  tags = {
    Name = "manju-vpc"
  }
}

-----------------------------------------------------------------

resource "aws_subnet" "main" {
  vpc_id           = aws_vpc.main.id
  cidr_block       = "10.0.0.0/24"
  availabilty_zone = "eu-north-1a"

  tags = {
    Name = "manju-subnet"
  }
}

-------------------------------------------------------------------

resource "aws_instance" "main" {
  ami                         = "ami-0dcc1e21636832c5d"
  instance_type               = "m5.large"
  subnet_id                   = "10.0.0.0/24"
  availability_zone           = "eu-north-1a"
  key_name                    = aws_key_pair.main.key_name
  associate_public_ip_address = true
  vpc_security_group_ids      = [aws_security_group.main.id]


 tags = {
    Name = "manju-instance"
  }
}

-------------------------------------------------------------------

resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = "manju-internet_gateway"
  }
}

--------------------------------------------------------------------

resource "aws_route_table" "main" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }

  tags = {
    Name = "manju-internet_gateway"
  }
}	

-----------------------------------------------------------------------


resource "aws_route_table_association" "main" {
  subnet_id      = aws_subnet.main.id
  route_table_id = aws_route_table.main.id
}

--------------------------------------------------------------------------

resource "aws_ec2_transit_gateway" "main" {
  description = "main"

  tags = {
  Name = "manju-transit_gateway"
  }
}

--------------------------------------------------------------------------
Resources you've created using Terraform:

1.Networking Components:

1.VPCs (Virtual Private Clouds)
2.Subnets
3.Route Tables and Associations
4.Security Groups and Network ACLs

2.Compute Resources:

1.EC2 Instances
2.Auto Scaling Groups:
3.Lambda Functions

3.Storage Resources:

1.S3 Buckets
2.EBS Volumes

4.Database Services:

1.RDS Instances
2.DynamoDB Tables

5.IAM and Security:

1.IAM Roles, Policies, and Users

6.Load Balancing and Distribution:

1.Elastic Load Balancers
2.Route 53

--------------------------------------------------------------------------
Types of pipelines you're handling in your project:

1.CI/CD Pipelines

a.Continuous Integration (CI) Pipelines
b.Continuous Deployment (CD) Pipelines

2.Infrastructure as Code (IaC) Pipelines
3.Release Pipelines
4.Security and Compliance Pipelines
5.Data Pipelines
6.Monitoring and Alerting Pipelines
7.Migration and Backup Pipelines

60 + Pipelines

-------------------------------------------------------------------------

provider "aws" {
  region = "us-west-2"
}

# Resource Definitions
resource "aws_instance" "example_instance" {
  # Attributes will be populated after import
}

resource "aws_s3_bucket" "example_bucket" {
  # Attributes will be populated after import
}

resource "aws_iam_user" "example_user" {
  # Attributes will be populated after import
}

# Import Blocks
import {
  to = aws_instance.example_instance
  id = "i-1234567890abcdef0" # Replace with your EC2 instance ID
}

import {
  to = aws_s3_bucket.example_bucket
  id = "my-existing-bucket" # Replace with your S3 bucket name
}

import {
  to = aws_iam_user.example_user
  id = "existing-user" # Replace with your IAM user name
}

--------------------------------------------------------------------

count     --> Creates multiple identical resources (count=3).
for_each  --> Creates resources based on a map/set(dynamic keys) 

terrafrom import --> Brings existing resources under terraform control
terraform state  --> Manages state(list,move,remove resources)

what is remote state, and why use it?
 
Remote state stores terraform state file in a shared location to enble 
collaboration and avoid conficts.

--------------------------------------------------------------------

variable "env" {
  default = "dev"
}


resource "aws_internet_gateway" "main" {
  count = var.env == "dev" ? 1 : 0

  vpc_id = aws_vpc.main.id
  tags = {
  Name = "manju-internet_gateway"
  }
}

count = var.env == "prod"? 1 : 0: This is a conditional expression. It checks the value of a variable called env:

If env is true, then count = 1 → internet_gateway will be created.

If false, then count = 0 → no internet_gateaway will be created.

--------------------------------------------------------------------
